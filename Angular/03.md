# Angular 9 - Partie 3 : Les directives
> - [Retourner √† la liste des cours](../readme.md)
> - Exercices : [cliquez-ici](exercices.md)
> - Corrections : [cliquez-ici](corrections.md)

- [Angular 9 - Partie 3 : Les directives](#angular-9---partie-3--les-directives)
  - [Mocking de data](#mocking-de-data)
    - [S√©l√©ctionner un h√©ros](#s%c3%a9l%c3%a9ctionner-un-h%c3%a9ros)
    - [G√©rer la s√©l√©ction d'un h√©ros](#g%c3%a9rer-la-s%c3%a9l%c3%a9ction-dun-h%c3%a9ros)

Nous allons apprendre √† structurer nos components gr√¢ce √† des directives : ce sont des instructions que nous injections directement  dans les balises afin de leur indiquer un comportement particulier.

- Les directives structurelles : elles servent √† structurer notre page en cr√©ant des √©l√©ments quand n√©cessaire, il s'agit en fait de conditions et de boucles ! Par exemple, afficher une `div` sous telle condition, afficher ce `li` autant de fois que n√©cessaire...

- Les directives par attribut : l√† o√π les directives structurelles cr√©√©ent des √©l√©ments, les directives par attribut modifient des √©l√©ments existants. Concr√®tement, elles nous permettent d'ajouter des styles et des classes conditionnels.

## Mocking de data

Notre application de gestion de h√©ros fonctionne bien... Pour un seul h√©ros. On peut imaginer que dans un cas r√©el, notre application ira r√©cup√©rer les donn√©es d'une base de donn√©es et que plusieurs h√©ros seront √† g√©rer !

Pour cela, nous allons *mocker*, c'est √† dire simuler, des donn√©es.

Cr√©ez le fichier `src/app/mock-heroes.ts`, qui contiendra un tableau d'objets `Hero`.

Pour cela, nous importons l'interface `Hero` de sorte √† ce que le fichier la reconnaisse, et nous exportons un tableau constitu√© d'objets `Hero` (on d√©finit ce tableau par le type `Hero[]`) :

![](img/c0301.png)

Ensuite,

1. nous allons importer ce fichier dans notre composant `app-heroes`, de sorte √† ce qu'on puisse utiliser ce tableau au sein de notre composant, 
2. nous allons supprimer notre attribut `hero` existante pour la remplacer par un attribut `heroes` qui contiendra notre liste de h√©ros.

![](img/c0302.png)

Du coup, un souci se pose (d'ailleurs, le serveur bugue !) : dans la partie HTML du component, on demande : `hero.name` et `hero.id`, qui sont des propri√©t√©s de l'attribut `hero`.

Hors, nous venons de le supprimer et de le remplacer par `heroes` (qui lui, contient de `Hero` !)

Nous allons donc dire √† notre HTML de faire une boucle sur ce nouveau tableau `heroes` pour afficher nos √©l√©ments. On en profite pour changer le visuel et mettre une liste `ul>li`. Dans le  `li`, nous mettrons le code existant de l'affiche d'un seul h√©ros :

![](img/c0303.png)

Et voil√† : gr√¢ce √† la directive `*ngFor`, nous avons pu dire √† notre code : "pour chaque `hero` du tableau `heroes`, fais un `li` qui ressemble √† √ßa".

![](img/c0303.png)
![](img/c0304.png)

### S√©l√©ctionner un h√©ros

Maintenant que nous avons tous nos h√©ros, nous allons g√©rer la s√©l√©ction d'un h√©ros pour afficher ses d√©tails √† droite de la page. Stylisons un peu mieux notre page pour travailler cette id√©e. 

Nous allons utiliser les colonnes Bootstrap pour faire une colonne de h√©ros, et une colonne de "modification".

![](img/c0307.png)

Le code pourrait √™tre comme suit :

![](img/c0306.png)

> Remarquez que comme notre formulaire n'est plus dans la boucle `*ngFor`, il ne peut plus conna√Ætre la variable `hero.name`. Donc, on enl√®ve le ngModel pour l'instant pour √©viter un bug !

### G√©rer la s√©l√©ction d'un h√©ros

Pour cela, nous allons avoir besoin de l'event binding: en effet, quand je clique sur un `li`, j'ai besoin d'indiquer au Typescript qu'un h√©ros a √©t√© s√©l√©ctionn√©. On √©coute donc le `(click)`  sur le `li`, et on appelle une m√©thode. √áa tombe bien, on a d√©j√† `onNameClick()` qui existe !

![](img/c0308.png)

> Remarquez que nous √©crivons les attributs de `li` en colonne. Tout fonctionnee pareil, c'est juste plus facile √† lire !

Modifions maintenant cette m√©thode `onNameClick()` pour qu'elle prenne en param√®tres un h√©ros cliqu√©.


- On modifie l'appel de la m√©thode dans `heroes.component.html` pour lui passer le param√®tre `hero`
- On modifie la m√©thode dans `heroes.component.ts` pour lui ajouter un param√®tre de type `Hero`
- On modifie la m√©thode pour lui dire d'afficher dans un `console.log` le h√©ros qui a √©t√© cliqu√© pour voir si tout fonctionne !

![](img/c0309.png)
![](img/c0310.gif)

> Ouf ! √áa fait d√©j√† beaucoup d'informations. On a pris quelques briques qu'on connaissait (les fonctions, l'event binding, la classe Hero...) pour r√©ussir √† faire en sorte que notre application Angular d√©tecte quel h√©ros a √©t√© cliqu√©, quand je clique n'importe o√π dans le `li` !

> Prenez un moment pour bien comprendre ce code avant de passer √† la suite.

Maintenant que notre h√©ros est d√©tectable, nous allons faire en sorte que notre fichier Typescript soit bien au courant. Pour cela, nous allons :
1. Cr√©er un attribut  `selectedHero: Hero`
2. Attribuer √† cet attribut le h√©ros qui a √©t√© s√©l√©ctionn√©.

![](img/c0311.png)

Gr√¢ce √† cet attribut, on est maintenant capable de tester si √† tout moment il existe un h√©ros qui a √©t√© cliqu√©. Et justement, concernant notre colonne de d√©tails... Elle ne devrait s'afficher seulement si un h√©ros a √©t√© cliqu√© ! On va pour cela utiliser la directive `*ngIf` qui affiche conditionnellement quelque chose. Ici, au d√©marrage de notre application, `selectedHero` est vide. Mais lorsqu'on le clique, il est rempli. Notre `div` s'affichera donc uniquement lors du clic !

Ajoutez le `*ngIf` :
![](img/c0312.png)
![](img/c0314.gif)

Parfait !

Et maintenant, dans cette div, notre code a acc√®s √† un h√©ros. √áa tombe √† pic : on peut r√©√©crire notre `ngModel` pour lui dire de se rattacher au h√©ros qui a √©t√© cliqu√© !

Rajoutez le `ngModel` :
![](img/c0313.png)
![](img/c0315.gif)

> Note de culture g√©n√©rale: ngModel fonctionne ici alors que nous avons deux variables diff√©rentes (un h√©ros issu de `heroes`, et un h√©ros dans `selectedHero`). Tout cela fonctionne gr√¢ce √† un design pattern nomm√© Singleton : groci√®rement, il s'agit pour l'application de n'avoir qu'un seul exemplaire de chaque objet en m√©moire. Donc quand on s√©l√©ctionne un h√©ros, l'application sait que ce h√©ros est d√©j√† en m√©moire, elle fait un "lien symbolique" vers cet emplacement m√©moire o√π le h√©ros se trouve. Ainsi, avec ngModel, on est certains de n'avoir qu'une seule copie du h√©ros et tout le component ne traite qu'avec les m√™me h√©ros !

Enfin, nous allons fair en sorte que la ligne s√©l√©ctionn√©e se mette en surbrillance quand elle est cliqu√©e.

Bonne nouvelle : il existe une classe Bootstrap pour √ßa ! üòÑ Il s'agit de la classe `active` √† rajouter √† notre `li`.

Nous sommes dans une boucle for qui affiche tous les h√©ros. Durant l'ex√©cution de cette boucle, la condition pour que la ligne s√©l√©ctionn√©e s'affiche est : *est-ce que le `selectedHero` correspond au `hero` que je suis en train d'afficher dans la liste ?* si oui, j'ajoute la classe `active`.

Cette condition d√©pend donc d'une donn√©e de Typscript, notre attribut (property) `selectedHero`. On a donc besoin d'un... Property binding !

Il s'√©crit comme √ßa :

```html
<li [class.nomDeLaClasseaAjouter] = "condition-√†-respecter">
```

Si la `condition-√†-respecter` est valide, alors la classe `nomDeLaClasse` sera rajout√©e √† notre `li`.

Ici, on a :
- classe : `active`
- condition: `hero === selectedHero` (hero √©tant le h√©ros qui est en train d'√™tre affich√©, de la boucle `let hero of heroes`)

On √©crit donc :

![](img/c0316.png)

√áa y est, on s'en sort, notre application est compl√®te !

![](img/c0317.gif)

- Faites l'[exercice 12](exercices.md#exercice-12).
- Faites l'[exercice 13](exercices.md#exercice-13).
- Faites l'[exercice 14](exercices.md#exercice-14).
